tokenization de l'opération

while (mot[i] != 10)
	call token_ope
	
	
	
token_ope(char *mot)
{
	while (mot[i] == '0')
	skip;
	si mot[i] == un des "+-*/()"
	si token_op actuel > tok.stack
	le mettre plutot dans output
	sauf si token_op actuel = '('
	si ')' alors call shuting_yard
	write in holding_stack mot[i]
	r9++ #r9 = holding_stack[sp]
	si '-' write also 1
	si '+' write 2
	si '*' or '/' : 3
	si '(' : 0
	r9++
	return r9
	si mot[i] == 'x'
	write in cache "x0123456789abcdef"
	sinon test si mot[i] == 'b'
	write in cache "b01"
	else write "d0123456789"
	
	i++
	
	while (mot[i] != ' ')
	écrire ds cache chaque char
	juste après la table_base
	(ex:b01)
	call atoi_base
	write in output_stack (r10)
	r10++
	return r10
}
atoi_base(char *mot)
{
	if mot[0] == 'x'
	r6 = *mot + 17 (pos du token)
	r8 = 16
	if mot[0] == 'b'
	r6 = *mot + 3
	r8 = 2
	sinon
	r6 = *mot + 11
	r8 = 10
	r5 = 0 #acc
	while (mot[i] != ' ')
	mul r5 par r8
	call find_idx
	r5 = r5 + r7
	return r5 (val int de la str)
}


find_idx(cache, r6#i)
{
	r7 = cache+1
	
	while (mot[r7] != mot[r6]
	ou que r7 < r8)
	r7++
	
	si r7 == r8 return error
	sinon r7 = r7 - cache - 1
	
	return r7
}
shuting_yard(r9, r10)
{
	compute r10 avec les arg
	(r10-2, r10-1) 
	case '-' : sub
	case '+' : add
	case '*' : mul
	case '/' : div
	
	puis r10 -= 2
	r9 -= 2 (car struct de 1*2oct)
	
	
